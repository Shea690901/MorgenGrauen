
LPmud,   a   programmable   multi   user   game.    Lars   Pensj|
lars@cd.chalmers.se

This is the (to be) documentation of LPmud and the LPC  language.
If  you  know  about a special fact not found, please add it, and
send me a patch.  Sorry if it is just a skeleton  so  far.   This
document is for LPmud version 3.0.a5.
































































General



Idea of the game

LPmud is a multi user adventure game.  That  means  that  several
players  can be playing the game at the same time, using the same
object database.  It also means that the players will  meet  each
other, and affect the game for other players.


History of LPmud

In the beginning, I played a lot of Abermud and some Tinymud, and
wanted to do something better, combining the two systems.  I made
the first version of LPmud as some kind of argument, to show that
my  ideas were possible.  Luckily, I didn't know at that time how
that would impact my near future.


Objects, files and programs

The programs defining the behaviour  of  objects  are  stored  in
files.   Every  object has exactly one file defining the program,
but every file may be used for more than  one  object.   When  an
object that is not loaded is referenced, it will automatically be
compiled and loaded.  More than one instance of an object can  be
created using the function is wanted.  Cloned objects may be con-
figured differently  after  creation,  hence  enabling  different
behaviour.


To allow or not allow emote

The following are some views that I (Lars Pensj|) have.  You  are
entirely  free  to depart from them.  There has been some discus-
sion on the net why only wizards have access to the 'emote'  com-
mand.

It was mentioned that some  living  objects  listen  to  specific
strings, which would be possible to fake.  However, these objects
should also verify that the action that seemed  to  have  happen,
really  did occur.  Many wizards do not realize that the check is
needed (even when there is no emote), and funny things happen  (I
am not free of guilt either).

But that is not the real reason why I dislike  'emote'  for  non-
wizards.   LPmud  is a competition-based game.  In some versions,
you are even allowed to kill other players (with real bad results
for  the  loser).   It  would be bad to allow the players to fake
message that could be used in combat situations.

The message 'Lars hit you with a  poisoned  knife'  for  example,
could  scare  of  unknowing players.  When you see a message, you
can be pretty sure that it means what it says.  That is why there
is  the rule that wizards should not do things that appears to do
things that they really don't do.   Non-wizards  are  not  really
supposed to be aware of the 'emote' command (maybe naive to think
so), which means that the wizards will appear  even  more  "god"-
like.

I want LPmud to have big differences  between  wizards  and  non-
wizards.   And also big differences between low level players and
high level players.  That means some kind of class system.   But,
the  system  will  allow  anyone  that  work  enough to reach the
highest levels.

What all this boils down to, is that I want there to  be  several
goals  for  the  players to reach.  Exciting goals makes the game
more interesting, and it is fun if everyone can be a winner.


Socializing

The original pub in LPmud, was created so that players could meet
and  have  some  socializing.   I  then implemented a scheme that
forced players to become drunk all the time.


File hierarchy

All files needed by the run time (game  driver)  resides  in  the
This  directory contains several sub-directories and files.  This
directory contains all saved player  files.   A  directory  which
might  be  open for anonymous ftp.  All standard rooms available.
All objects that are used by standard rooms  and  player  defined
objects.


Commands tied to functions in objects

All commands except a very few special cases are defined  by  the
objects.   All commands have a simple basic way to be recognized.
The first word of the sentence is supposed to be the  Every  com-
mand  defined  is  tied to a special function in an object.  Com-
mands are defined with the function which specifies the  verb  to
be  recognised,  and the name of the local function to be called.
When a living object gives a command which matches a verb with  a
command  defined  by  an  object, then the corresponding function
will be called in the specified object.  If this function returns
0,  then  next command with the same verb is tried.  If the func-
tion returns 1, then  he  search  is  terminated.   This  enables
several objects to define commands with the same verbs, but still
behave different if the rest of the sentence differs.  For  exam-
ple,  there  might be two armours. One is named "leather jacket",
and one is named "plate mail".  Both objects will have defined  a
command  with  the  verb  If  the  player  now  gives the command
"wear jacket", then we can't know which defined command is called
first.   Suppose  that  the  function in the plate mail is called
first.  It will then detect that the argument to is "jacket", not
"plate mail".   It  would  then  return 0, which would enable the
game driver to call  the  command  in  the  leather  jacket  that
defines  the  verb.   This function would accept the command, and
execute some appropriate code, followed by a return of 1.

Every time an object comes in contact with a living  object  then
will be asked to define commands.  See below in for more informa-
tion.


Relation between object definitions

Objects can reside either on top level, or inside another object.
There is no relation like "on", "behind" etc.


The basic inheritance structure

This is a picture of  how  basic  object  inheritance  is  built.
Below is a list of names, and what object inherits them.

std/object    and    global/std/link_commands.     std/container,
std/weapon    and   std/armour.    std/living.    std/player_sec.
std/player_pub global/std/misc_cmd and global/std/soul_cmd.

A description of what is defined in  the  files.   Here  are  LPC
functions  that  are  not defined in basic LPC, but should.  When
they will become defined, they will be removed  from  this  file.
For  example,  member_array(), map() exclude_array().  This
is the basic file  for  all  objects  that  will  be  visible  to
players.   Basic  configuration functions are defined.  For exam-
ple,   set_name(),   set_short(),   set_value(),    set_weight(),
add_prop(),  move() and many more.  This file is the base for all
objects that are supposed to be able to  contain  other  objects.
Functions defined are add_item(), set_internal() and manipulation
of properties regarding containers.   The  base  for  all  living
objects in the game.  The fighting is defined here.  The base for
all objects that an interactive player can connect to.  Functions
defined  here,  are functions that wizards are not supposed to be
able to modify or redefine.  For example,  the  quest  functions.
Default  functions,  possible to redefine by wizards who wants to
make their own player object.  ?  ?  To std/player_sec are  three
soul-objects  connected  through links.  These are used in such a
way, so that player_sec will ask the object for a  list  of  com-
mands  and  functions,  which  are  called.  Basic commands, like
'smile', 'laugh' etc.  All other  player  commands,  like  'get',
'put', 'drop', 'help', All wizard specific commands.

As soul_cmd and misc_cmd not is visible objects, they  will  only
inherit std/simul_efun and not std/object.


Automatic call of functions in objects



What happens when objects are moved

Every time an object is moved, a some code will be called an exe-
cuted  automatically.   Below, is a living object.  When is moved
into a room, the function will be called in both the room and  in
all other objects in that room.  When an object is moved into the
inventory of or into the same room as then will be called in that
object.   When objects are removed from the vincinity of then all
commands defined by these are objects are removed from  the  list
of commands available to


The reset of objects

The function will be called in objects  at  two  occasions.   The
first  occasion  is when the object is loaded for the first time.
Then, will be called with 0 as argument.  The other  occasion  is
at  irregular  intervals,  where  will  be called repeatedly with
argument 1.  The length of the interval is based  on  a  constant
defined  by  the  person that set the mud up, and plus/minus some
random value.

A note of warning is in place here.  If there is a  room  defined
like this:
reset(arg) {
        if (!present("troll")) {
                object troll;
                troll = clone_object("players/someone/troll");
                move_object(troll, this_object());
                }
        if (arg) return;
        set_light(1);
        short_desc = "My room";
        long_desc = ...
        dest_dir = ...
}
Then, the will be loaded into the room before the exits has  been
set up.  That means that the troll can't move.

There is another problem that should be known.  An object can  be
loaded  from  several  reasons.   When it is being moved.  When a
function is called in it.  When it is cloned.  When it is  inher-
ited  by  another  object.   And  in  every  instance of loading,
reset() will be called with 0 as argument.


How to handle when a player enters a box etc

Suppose there is a big box in the room, which makes  it  possible
for  players  to  enter.   Players entering the box should not be
transfered to the inventory of the box, but rather to a new room,
which would represent the interiour of the box.

There is a specific reason for this.  When a  player  arrives  to
the  room  with  the box, the function will be called in the box,
which will define the command.   But,  if  the  player  would  be
transfered  into the box, he would again have an command defined.
Similar problems exists for the and functions.  They should  give
different messages depending on if the player is on the inside or
the outside of the box.


The security system

Every object has two They are used for to determine if an  object
has  permission to read and write files, and to find out who owns
an object.  They are named and and are strings.  The is the  user
id,  and the is the effective user id.  When an object is created
by either loading or cloning, then it will have  and  initialized
to  the  value of of the object that was the cause of the cloning
or loading.  It is the that is used to determine permissions.  It
can  be  changed to other values, using What it can be set to, is
decided by in /obj/master.c.  It can always be set to '0'.   When
it is '0', the object has no permissions at all.  It can not even
clone or load other objects.

There is a function that returns the of the object There is  also
a  function  that  sets the of object to the current But, only if
object has its current set to 0.

There are two functions, and defined in /obj/master.c.  They both
take  two arguments: a file name and an effective uid.  They will
be called automatically by the game driver  to  determine  if  an
object  has  a specific permission.  They will return 0 or 1, for
and Compare wih the old version of LPmud, where these  two  func-
tions  were  defined in player.c, and also modified the file name
(using the current working directory).

The function in /obj/master.c should return the that has  permis-
sion to do anything.

When a castle is loaded automatically at startup, the must be set
to  the permission of the owner of the castle.  Thus, all objects
loaded by this castle will inherit this permission.


Example

Suppose we have a room "/players/martha/pit.c".  This  room  will
have the same as the castle, which will probably be "martha".  If
this  room  is   initialized   with   a   knife,   defined   from
"/obj/weapon.c", then this weapon will inherit the "martha".


Example

The player object will have the  highest  permission,  which  for
instance can be "root".  If the player is a wizard, then we don't
want all objects cloned by the wizard to have this If the name of
the  wizard is "martha", then the player object will do a call to
at log in.  This will trigger a call to in  /obj/master.c,  which
will  return  1  because  "root" is allowed to change to anything
else.


Example

So far, the examples shown has worked with no problems.  There is
a  problem,  though, and that is when the a player moves from (as
an example) "/players/martha/pit.c" to "/room/vill_green.c".   If
this  "/room/vill_green.c"  was not loaded, then it will promptly
become loaded, it will get the "martha".  It should have the same
as   all   standard   rooms,   which   is   maybe   "root".   So,
"/room/vill_green.c" will call in Then, will again be called, and
this  time  it will accept the "root" because the file name shows
that it is a standard object.  This all means  that  there  is  a
bunch  of  objects  that  has to set their to the correct values.
This will normally only be needed for rooms, and  can  easily  be
solved  by a call to in the defined by /room/room.c.  If a wizard
makes his own room from scratch, then he better know what to  do.
If  he  fails  to set his own for his own room, then his room can
not files in his directory etc.


LPC reference manual

The language used to program objects are called It  is  syntacti-
cally modelled after C.  As it is important that objects be load-
able "on fly" in a game, I  choose  to  make  it  an  interpreted
language.   If  it would be compiled for real, there would be big
problems of portability when moving to different  machines.   The
security  of  the  program is also very important.  Under no cir-
cumstances should a LPC programmer crash the game by doing a mis-
take.  That rules out standard C.

An LPC programs consists several building blocks:


Types declarations

Types can be used at four places: Declaring type of global  vari-
ables.  Declaring type of functions.  Declaring type of arguments
to functions.  Declaring type of local  variables  to  functions.
Normally,  the type information is completely ignored, and can be
regarded purely sa documentation.  However, when the  basic  type
of  a function is declared, then a more strict type checking will
be enforced.  That means that the type of all arguments  must  be
defined.   And, the variables can only be used to store values of
the declared type.  The function is defined to return  an  unkown
type,  as  the  compiler  can't  know  the type.  This value must
always be casted (when strict type checking is enabled).  Casting
a  type is done by putting the type name inside a pair of '(' and
An example when querying the short description of an object:
(string)call_other(ob, "short");
There are two kinds of types.  Basic types,  and  special  types.
There  can  be  at most one basic type, but any number of special
types.  The strict type checking is only used  by  the  compiler,
not  by  the  runtime.  Hence, it is actually possible to store a
number in a string variable even when  strict  type  checking  is
enabled.

Why use strict type checking ?  It is really recommended, because
the  compiler  will  find many errors at compile time, which will
save a lot of hard work.  It is in general much harder  to  trace
an  error  occuring at run time.  I recommend, that when a wizard
is having problem with an object and wants help,  that  he  first
must make all functions have declared types.


Basic types

An integer 32 bit number.   Pointer  to  an  object.   An  object
pointer  can  mainly  be  used  for two things.  Either giving as
argument to functions, or used for calling functions  defined  by
that  object  with its specific instance of variables.  An unlim-
ited string of characters.  A lot of operators  are  allowed  for
strings, like and etc.  This type is special, in that it is valid
to use in any context.  Thus, if everything was declared then the
compiler  would  never complain.  This is of course not the idea.
It is really only supposed to be used when a variable  really  is
going  to  contain different types of values.  This be avoided if
possible.  It is good coding practice, to allow  a  function  for
example  to return different types.  This type is only usable for
functions.  It means that the function will not return any value.
The compiler will complain (when type checking is enabled) if the
return value is used.


Arrays

Arrays are declared using a '*' with a basic type.  For  example,
declaring  an array of numbers: "int *arr;".  Use the type if you
want an array of arrays, or a mixed combination of types.


Special types

There are some special types, which can be given before the basic
type.  These special types can also be combined.  When using spe-
cial type before an statement, all symbols defined by inheritance
will  also get the special type The only special case is symbols,
which can not be redefined as in a statement.  Can be  given  for
both  functions  and variables.  Functions that are in object can
not be called through from another object.   And,  they  are  not
accessible  to any object that inherits This special type behaves
different for variables and functions.   It  is  similar  to  for
functions,  in  that  they  can not be called from other objects.
variables will be neither saved nor restored when  calling  or  A
function defined as will always be accessible from other objects,
even if is used.  All symbols defined as can not be redefined  by
inheritance.  They can still be used and accessed as usual.


Access of data and programs in other objects

There is a function that can be used to call functions in  nother
objects.   All  functions  can be called except those declared or
See  "Predefined functions"  for  more  information.   There   is
another syntax that will do the same thing:

ob->func(args)

This will call function in object It is a much more  good-looking
way to do it.

There has been a lot of questions why  this  syntax  hasn't  been
used  to  allow  for accessing variables in other objects.  There
are some good reasons for that.  It conflicts with  the  idea  of
programming  in an object-oriented way.  It makes the programming
less structured, as there are more dependencies.  If  a  variable
name  is  changed, code can be broken.  Sometimes, you don't even
want to keep the variable at all any longer.


Predefined functions

There are two kinds of predefined functions: The functions  which
are defined by the game driver.  They can be redefined by a local
function of the same name,  which  will  then  be  used  instead.
Functions  that  optionally can be defined by the objects.  These
functions will be called by  other  and  sometimes  by  the  game
driver.   They will control how the object will behave in special
situations.  An example is which if defined and returning 1, will
enable  the  object  to be picked up by players.  If returning 0,
then the player will get a message  that  says  that  the  object
can't be picked up.


efuns



add_action

void add_action(string fun, string cmd, int flag);

Set up a local function  "fun"  to  be  called  when  user  input
matches  the  command "cmd". Functions called by a player command
will get the arguments as a string. It must then return 0  if  it
was the wrong command, otherwise 1.

If it was the wrong command, the parser will  continue  searching
for another command, until one returns true or give error message
to player.

For example, there can be a wand and a rod. Both of these objects
defines  add_verb("wave").  One  of  them will be randomly called
first, and it must look at the argument, and match against "wand"
or "rod" respectively.

If seconds argument ("cmd") is not give,  it  must  be  given  by
add_verb().  Support of add_verb() is of historical reasons.

Always have add_action() called only from an init() routine.  The
object  that  defines  commands  must  be  present to the player,
either being the player, being carried by the player,  being  the
room  around  the  player, or being an object in the same room as
the player.

If argument 'flag' is 1, then only the leading characters of  the
command has to match the verb 'cmd'.

Never define an  action  that  will  call  the  function  exit(),
because it is a special function.

See also efun/query_verb, efun/add_verb, lfun/init, lfun/exit


add_verb

void add_verb(string str);

This function is connected to  the  "add_action()"  function.  It
will  set  up the command "str" to trigger a call to the function
set up by the previous call to "add_action()".

This function is now obsolete as the verb can be  given  directly
with add_action(). add_verb() remains for compatibility.

See also efun/add_action efun/query_verb


all_inventory

all_inventory(object ob);

Returns an array of the objects contained  in  the  inventory  of
"ob".

See also first_inventory(), next_inventory().

allocate

allocate(int size);

Allocate an array of 'size' elements. The number of elements must
be >= 0 and not bigger than a system maximum (usually 1000).

See also: efun/sizeof


call_other

call_other(object ob, string str, mixed arg);

Call function in another object  with  an  argument.  The  return
value is returned from the other object.

See also present(), find_living().


call_out

void call_out(fun, delay, arg) string fun; int delay;

Set up a call of function 'fun' in this_object(). The  call  will
take  place in 'delay' seconds, with the argument 'arg' provided.
'arg' can be of any type.

Please note that you can't rely on 'write' or 'say' in the  'fun'
called  since  this_player()  is  set  to  0. Use 'tell_object()'
instead.

See also efun/remove_call_out efun/call_out_info


capitalize

string capitalize(string str);

Convert the first character in "str" to upper  case,  and  return
the new string.

See also efun/lower_case


cat

int cat(string path, int start, int num);

List the file found at "path". It is not legal  to  have  '.'  or
spaces  in  the  path. This commands is normally connected to the
"cat" command that wizards have. It is also used  by  the  "help"
command.  The optional arguments 'start' and 'num' makes is start
line number, and number of lines.  If they  are  not  given,  the
whole file is printed from the beginning.

The total number lines will not exceed a system limit, which nor-
mally is 40 lines.

cat() returns 1 if success, 0 if no such file or no such lines.

See also efun/ls efun/file_size efun/read_file


catch

catch(expr)

Evaluate 'expr'. If there is no error, 0 is returned. If there is
a standard error, a string (with a leading '*') will be returned.

The function throw(value) can also be used to immediately  return
any value, except 0. catch() is not really a function call, but a
directive to the compiler.

The catch() is somewhat costly, and should not be used  anywhere.
Rather,  use  it  at  places  where  an  error would destroy con-
sistency.

See also efun/throw


clear_bit

string clear_bit(string str, int n);

Return the new string where bit 'n' is cleared in  string  'str'.
Note that the old string 'str' is not modified.

See also efun/set_bit efun/test_bit


clone_object

object clone_object(string name);

Load a new object from definition  "name",  and  give  it  a  new
unique  name. Return the new object.  The original used for clon-
ing, should not be used in the game, only used for cloning.

See also efun/destruct efun/move_object


command

int command(string str, object ob);

Execute "str" as a command given directly  by  the  player.   Any
effects  of the command will apply to the current object.  If the
second optional argument is present, then the command is executed
for that object.

Return value is 0 for failure.  Otherwise,  a  numeric  value  is
returned,  which  tells  the evaluation cost. Bigger number means
higher cost. The evaluation cost is approximately the  number  of
of machine code instructions executed.

See also efun/enable_commands


create_wizard

string create_wizard(string name);

Create the environment and castle for a wizard. Do NOT  use  this
if  you are not sure about what you are doing !  It will create a
new directory for wizard with the name "name", and copy a defini-
tion of a castle to this directory. It will also set up automatic
loading of this castle for the start of the game.

It returns the name of the new castle. In case  of  error,  0  is
returned.


creator

string creator(ob) object ob;

Return as a string the name of the  wizard  that  created  object
'ob'. If the object was not created by a wizard, 0 is returned.


crypt

string crypt(str, seed);

Crypt the string 'str' using two  characters  from  'seed'  as  a
seed. If

The result has the first two characters as the seed.


ctime

string ctime(clock) int clock;

Give a nice string with current date and time, with the  argument
'clock' that is the number of seconds since 1970.

See also: efun/time


destruct

void destruct(ob) object ob;

Completely destroy and remove object "ob". The argument can  also
be  a  string.  After the call to destruct(), no global variables
will exist any longer, only local, and arguments.

If an object self-destructs, it will immediately terminate execu-
tion  and  return  0.  There  is  one exception: If the destruct-
statement is followed by a 'return  1'  immediately  after,  then
this return statement will be executed.

This should NOT be used on normal objects in  the  game,  instead
use the lfun correct update of weights, volumes etc

See also clone_object().


ed

void ed(file) string file;

This is a funny function. It will start  a  local  editor  on  an
optional file.  This editor is almost ed compatible.


enable_commands

void enable_commands()

Enable  this  object  to  use  commands  normally  accessible  to
players.   This  also marks the current object as "living".  Com-
mands defined by 'player.c' will not be accessible, of course.

This function must  be  called  if  the  object  is  supposed  to
interact with other players.

Avoid to call this  function  from  other  places  then  reset(),
because the command_giver will be set to the this object.

See also efun/command, efun/living.


environment

object environment(obj) object obj;

Return the surrounding object to "obj". If no argument is giving,
it  returns  the  surrounding  to the current object.  The object
will dissapear silently without any sign.

See also find_first_inventory(), this_player(), this_object().


explode

explode(str, del) string str, del;

Return an array of strings, created  when  the  string  'str'  is
splitted  into substrings as divided by 'del'. The 'str' must end
with 'del' if the last part is wanted too.

Example: explode(str, " ") will split the string  'str'  into  an
array of words as separated by spaces in the original string. The
array is returned.

See also: efun/sscanf efun/extract efun/sscanf


extract

string extract(string str, int from, int to)

Extract a substring from a string. Character 0 is  first  charac-
ter.   "extract(str,  n)"  will  return a substring from characer
number 'n' to the end.  "ectract(str, i, j)" will return a string
from character 'i' to character 'j'.

See also efun/sscanf efun/explode


object_name

string object_name(ob) object ob;

Get the file name of an object. If the object is a cloned object,
then  it  will not have any corresponding file name, but rather a
new name based on the original file name.

Example: "find_object(object_name(ob)) == ob" is guaranteed  to  be
true for all objects 'ob'.


file_size

int file_size(file) string file;

Give the size of a file. Size -1 indicates that the  file  either
does  not exist, or that it is not readable by you. Size -2 indi-
cates that it is a directory.

See  also:  efun/save_object   efun/load_object   efun/write_file
efun/cat


find_living

object find_living(str) string str;

Find first "living" object that answers to the id "str" (by  cal-
ling  local  id()).  A  living  object is an object that has done
"enable_commands()".

The object must have set a name with  'set_living_name()'.  There
is  a  special  hash  table  that speeds up the search for living
objects.

See       also       efun/find_player        efun/enable_commands
efun/set_living_name


map

pointerp map(arr, fun, ob, extra) pointerp arr; string fun;
object ob;

Returns an array holding the items of 'arr'  mapped  through  ob-
>fun().  The function 'fun' in 'ob' is called for each element in
'arr' with that element as parameter. A second parameter  'extra'
is   sent   in   each   call   if   given.   Principal  function:
        foreach (index) arr[index] = ob->fun(arr[index],extra);

The value returned by ob->fun(arr[.index.], extra)  replaces  the
existing  element  in the array. If 'arr' is not an array, then 0
will be returned.


find_object

object find_object(str) string str;

Find an object with the  file  name  'str'.  If  the  file  isn't
loaded, it will not be found.


find_player

object find_player(str) string str;

Find a player with the name 'str'. The string must be  lowercase.
Players  are  found even if they are invisible or link dead. Mon-
sters are not found.

This function uses the name that was set by  'set_living_name()'.
This is done automatically in player.c.

See also efun/find_living efun/set_living_name


first_inventory

object first_inventory(ob) object ob;

Get the first object in the inventory of "ob".

See also next_inventory(), all_inventory().


function_exists

string function_exists(str, ob) string str; object ob;

Return the file name of the  object  that  defines  the  function
'str'  in  object  'ob'.  The  returned  value  can be other than
object_name(ob) if the function is defined by an inherited object.

0 is returned if the function was not defined.


implode

string implode(arr, del)

Concatenate all strings found in array  'arr',  with  the  string
'del' between each element. Only strings are used from the array.

See also: efun/explode


input_to

void input_to(fun, flag) string fun; int flag;

Enable next line of user input to be sent to the  local  function
"fun" as an argument. The input line will not be parsed.

Note that "fun" is not called immediately. It will not be  called
until  the  current  execution has terminated, and the player has
given a new command.

If input_to() is called more than once  in  the  same  execution,
only the first call has any effect.

If optional argument 'flag' is non-zero, the line  given  by  the
player will not be echoed, and is not seen if snooped.

See also call_other(), sscanf().


intp

int intp(arg)

Return 1 if 'arg' is an integer number.

See also efun/stringp, efun/pointerp, efun/objectp


living

int living(ob) object ob;

Return  true   if   'ob'   is   a   living   object   (that   is,
enable_commands() has been called by 'ob').


log_file

void log_file(file, message) string file; string message;

Append a message to a log file. All log files are in  the  direc-
tory mudlib/log.


See also: efun/write_file


lower_case

string lower_case(str) string str;

Convert the all characters in "str" to lower case, and return the
new string.


ls

void ls(path) char path;

List files in an optional path. It is not allowed to use  '.'  or
space  in  the  path.  This function is normally connected to the
"ls" command that a wiz have.

See also cat().


move_object

void move_object(item, dest) object item; object dest;

Move the object "item" to  the  object  "dest".  Currently,  both
arguments  can  be  strings. Usually, 'transfer()' should be used
instead of

See also efun/transfer,  efun/first_inventory,  efun/this_object,
         efun/this_player


next_inventory

object next_inventory(ob) object ob;

Get next object in the same inventory as "ob".

Warning: If the object  'ob'  is  moved  by  move_object(),  then
next_inventory() will return an object from the new inventory.

See also efun/first_inventory, efun/all_inventory.


notify_fail

void notify_fail(string str);

Store 'str' as the error message given  instead  of  the  default
message 'What ?'.

If notify_fail() is called more than once, only the last call  of
will be used.

The idea of this  function  is  to  give  better  error  messages
instead of simply 'What ?'.


objectp

int objectp(arg)

Return 1 if 'arg' is an object.

See also efun/intp, efun/stringp, efun/pointerp


parse_command

int parse_command(string str, mixed source, string pattern, var1,
var2 ...);

Parses commands given in "str" against the pattern  in  "pattern"
and  returns  1 if it matches. "source" is either an object or an
array of objects.  This is essentially a 'hotted' sscanf  and  it
has  a similar syntax, although parse_command works on word basis
where sscanf works on character basis.

Given command Either an array holding the accessible objects,  or
an object from which to recurse and create the list of accessible
objects, normally ob = environment(this_player()) .

Parse pattern as list of words and formats:
                Syntax:
                        'word'          obligatory text (One word)
                        [word]          optional text (One word)
                        /               Alternative marker
                        %o              Single item, object
                        %l              Single living object
                        %s              Any text (multiple words)
                        %w              Any word
                        %p              Preposition
                        %i              Any items
                        %d              Number 0- or tx(0-99)
Example string: " 'get' / 'take' %i " .  Items as in  %o  and  %i
can on many forms, some examples:
                        apple, two apples, twentyfirst apple
                        apples, all apples, all green apples, all green ones

This is the list of result variables as in sscanf.  One  variable
is needed for each %_.  The return types of different %_ is:
        %o      Returns an object
        %l      Returns an object
        %s      Returns a string of words
        %w      Returns a string of one word
        %p      Can on entry hold a list of word in array
                or an empty variable
                Returns:
                   if empty variable: a string
                   if array: array[0]=matched word
        %i      Returns a special array on the form:
                [0] = (int) given numeric prefix
                       =0: all or a pluralform given
                       >0: numeral given: two, three, four...
                       <0: order given: second, third ...
                [1..n] (object) Objectpointers
                       A list of the POSSIBLE objects that can match
                       the given %i. No choosing of third or such.
        %d      Returns a number
Example:

a=parse_command("take apple",environment(this_player()),
" 'get' / 'take' %i ",items);



people

void people()

A function that will list all interactive players, and some  info
about  them.  This function is normally connected to the "people"
command, that wizards have.

THIS FUNCTION IS OBSOLETE. LOOK AT efun/users() INSTEAD.


pointerp

int pointerp(arg)

Return 1 if 'arg' is a string.

See also efun/intp, efun/stringp, efun/objectp


present

object present(str, ob) string str; object ob;

If an object that identifies to the name "str" is  present,  then
return it.


The object is searched  for  in  the  inventory  of  the  current
object,  and  in  the inventory of the environment of the current
object.

A second optional argument  'ob'  is  the  enviroment  where  the
search for the

See also efun/move_object(), efun/environment().


previous_object

object previous_object()

Returns an object pointer to the object that called current func-
tion, if any.

See also: efun/call_other


query_idle

int query_idle(ob) object ob;

Query how many seconds idle a player object has been.


query_verb

string query_verb()

Give the name of the current command, or 0 if not executing  from
a  command.  This enables add_action() of several commands to teh
same function.

See also efun/add_action().


random

int random(n) int n;

Return a number in the random range [0 .. n-1].


remove_call_out

int remove_call_out(fun) string fun;

Remove next pending call out for function 'fun' in  this  object.
The time left is returned.

-1 is returned if there were no call out pending  to  this  func-
tion.

See also efun/call_out efun/call_out_info


save_object

void save_object(name) string name;

Save values of variables of this object in the file  "name".   It
is  illegal  to have '.' or space in the field name. Wizards that
call this function can only save to files  in  their  own  direc-
tories.

Objectpointers are stored as the number '0'.  Variables that  has
the type modifer 'static' will not be saved. Example: 'static int
xxx;'.

See also efun/restore_object


restore_object

int restore_object(name) string name;

Restore values of variables for current object from file  "name".
It  is illegal to have '.' or spaces in the name.  Return true if
success.

Variables that has the type modifer 'static' will not  be  saved.
Example: 'static int xxx;'.

See also efun/save_object


say

void say(str) string str;

void say(str,obj) string str; object obj;

Send a message "str" to all players in the  same  object  (room).
This function is also used by the "say" command.

If second argumnet "obj"  specified,  messages  is  semt  to  all
except "obj".

This commands behaves differently if called from a  heart_beat(),
or  otherwise.  When called from a heart_beat(), the message will
reach all players in the same  environment  of  the  object  that
calls say().

See also write(), shout(), tell().


set_bit

string set_bit(str, n) string str; int n;

Return the new string where bit 'n' is set in string 'str'.  Note
that the old string 'str' is not modified.

The max value of 'n' is limited. Ask  the  administrator  if  you
want to now the maximum value.

The new string will automatically be extended if needed.

Bits are packed 6 per byte in printable strings.

See also efun/clear_bit efun/test_bit


set_heart_beat

int set_heart_beat(flag) int flag;

Enable or disable heart beat. If the heart beat is not needed for
the  moment,  then  do  disable  it. This will reduce system over
head.

Return true for success, and false for failure. Specifically,  it
will  fail if the heart beat function has been disabled, which it
will be if there is a run time error in it.

See also lfun/heart_beat


set_light

int set_light(n) int n;

An object is by default dark. It can be set to not dark  by  cal-
ling  set_light(1). The environment will the also get this light.
The returned value is the total number of lights in this room.

Note that the value of the argument is added to the light of  the
current argument !


set_living_name

void set_living_name(name) string name;

Set a living name on an object that must be living. When this  is
done, the object can be found with find_living().

An object can only have one name that can be  searched  for  with
find_living().

See also efun/find_living efun/find_player


shout

void shout(str) string str;

Send a string "str" to all players. This function is also used by
the "shout" command.

See also write(), tell_object(), say().



sizeof

int sizeof(arr)

Return the number of arguments of an array 'arr'.   If  'arr'  is
not an array, then '0' is returned.

See also: efun/allocate


slice_array

slice_array(arr,from,to) array arr; int from; int to;

Returns an array that is a slice of  the  array  'arr'  from  the
index 'from' to the index 'to'. Indexes are numbered 0-

If 'arr' is not an array or indexes are  outside  the  limits  of
'arr', then 0 will be returned.

Note also that you can use the operator '+' on arrays.



sscanf

int sscanf(str, fmt, var1, var2 ...) string str; string fmt;

Parse a string "str" using the format "fmt".  "fmt"  can  contain
strings   separated  by  "%d"  and  "%s".  Every  "%d"  and  "%s"
corresponds to one of var1, var2...  "%d" will give a number, and
"%s" will give a string.

Number of matched "%d" and "%s" is returned.

See also efun/extract efun/explode.


stringp

int stringp(arg)

Return 1 if 'arg' is a string.

See also efun/intp, efun/pointerp, efun/objectp


tell_object

void tell_object(ob, str) object ob; string str;

Send a message "str" to object "ob".  If  it  is  an  interactive
object  (a player), then the message will go to him, otherwise it
will go to the local function "catch_tell".

See also write(), shout(), say().


tell_room

void tell_room(ob, str) object ob; string str;

Send a message "str" to object all objects in the room "ob".

See also efun/write, efun/shout, efun/say, efun/tell_object


test_bit

int test_bit(str, n) string str; int n;

Return 0 or 1 of bit 'n' was set in string 'str'.

See also: efun/set_bit efun/clear_bit


this_object

object this_object()

Return the object pointer of this object. This is not to be  con-
fused  with  the internal name of an object, which is used by the
"id()" function.

See also: this_player().


this_player

object this_player()

Return the object representing the current player.

See also: this_object().


time

int time()

Return number of seconds since 1970.

See also: efun/ctime


getuid

string getuid(object ob)

Get the name of the wizard that  is  set  to  the  user  of  this
object.  That name is also the name used in the wizlist.

See also efun/seteuid


users

users()

Return an array of objects, containing all interactive players.


write

void write(str) string str;

Write a message "str" to current player.  "str"  can  also  be  a
number, which will be translated to a string.

See also: say(), tell_object(), shout().


write_file

int write_file(file, str) string file, str;

Append the string 'str' into the file 'file'. Returns 0 or 1  for
failure or success.

See also: efun/file_size efun/cat efun/log_file


rm

int rm(string file)

Remove file 'file'. Returns 0 for failure and 1 for success.

See also efun/mkdir efun/rmdir


filter

pointerp filter(mixed *arr, string fun,  object  ob,  mixed
extra);

Returns an array holding the items of 'arr' filtered through  ob-
>fun().  The function 'fun' in 'ob' is called for each element in
'arr' with that element as parameter. A second parameter  'extra'
is  sent  in  each call if given. If ob->fun(arr[.index.], extra)
returns 1 the element is included in the returned array.

If 'arr' is not an array, then 0 will be returned.


unique_array

pointerp  unique_array(obarr,separator)  pointerp  obarr;  string
separator;

Groups  objects  together  for  which  the  'separator'  function
returns  the  same  value. 'obarr' should be an array of objects,
other types are ignored.  The 'separator' function is called only
once  in  each object in 'obarr'. The return value is an array of
arrays of objects on the form:

   ({
       ({Same1:1, Same1:2, Same1:3, .... Same1:N }),
       ({Same2:1, Same2:2, Same2:3, .... Same2:N }),
       ({Same3:1, Same3:2, Same3:3, .... Same3:N }),
                     ....
                     ....
       ({SameM:1, SameM:2, SameM:3, .... SameM:N }),
   })



export_uid

int export_uid(object ob)

Set the uid of object 'ob' to this_object's effective uid. It  is
only possible when object 'ob' has an effective uid of 0.

See also efun/seteuid efun/getuid


seteuid

int seteuid(string str)

Set effective uid to 'str'. It is not possible to set it  to  any
string.   It  can  always  be set to getuid(), the creator of the
file for this object or 0.

When this value is 0, then current objects uid can be changed  by
export_uid, and only then.

But, when the value is 0, no objects can be loaded or  cloned  by
this object.

See also efun/export_uid efun/getuid


call_out_info

mixed *call_out_info()

Get  information  about  all  pending  call  outs.  An  array  is
returned, where every item in the array consists 4 elements:

The object.  The function.  The delay to go.  The optional  argu-
ment.

See also: efun/call_out efun/remove_call_out


read_file

string read_file(string file);

Return the contents of the file 'file'. There is a maximum limit.

See also: efun/file_size efun/cat efun/log_file efun/write_file


throw

void throw(mixed val);

Terminate execution, and make the currently  executing  'catch()'
return 'val'.

See also efun/catch


lfuns



move

int move(object dest);

Move the object to the object "dest".  All  kinds  of  tests  are
done, and a number is returned specifying the result:

0: Success.
1: To heavy for destination.
2: Can't be dropped.
3: Can't take it out of it's container.
4: The object can't be inserted into bags etc.
5: The destination doesn't allow insertions of objects.
6: The object can't be picked up.

If an object is transfered to a newly created object,  make  sure
that the new object first is moved to it's destination.




Statements



if



block



while



do - while



for



return



Expressions



Saving and restoring objects



Inheritance



Compilation errors



Runtime errors



The preprocessor

A number of preprocessor defined lines can  be  used.   They  are
very  similar to the C preprocessor Used for conditional compila-
tion.  Takes a name as argument, and will  leave  or  remove  the
following  code to the compiler until next or depending on if the
argument is a defined symbol or not.  See fro how to define  sym-
bols.  It is possible to have inside each others.  Same as except
the condition is evaluated as true if the argument  evaluates  as
non-zero.   Used to terminate an or clause.  Will toggle the con-
ditional compilation.  Define a symbol.  The symbol can either be
defined  as another textual entity, or simply defined to nothing.
In either case, the symbol will enable the statment  to  evaluate
as true.  If the symbol is defined as something, then that symbol
will be replaced with that something in the  rest  of  the  file.
Arguments  can  be used to define macros.  The string argument is
evaluated as a file, which will be included  at  that  point.   A
good rule is to never include files with LPC code in, only proto-
types and other preprocessor definitions.  Will  force  usage  of
type  declarations  in  the  rest  of  this file.  This is really
recommended for complex files.


The LPC implementation

The language is defined by two files.  defines the lexical eleme-
ments  and  takes  care  of preprocessor directives.  defines the
grammar.


The virtual stack machine



How to add your own functions

All predefined functions  callable  by  the  object  must  return
exactly  one  result  on  the  stack, even if they are defined as
'void' functions. The compiler assumes that there always are  one
resulting value.

The functions that returns the 'void' value, might as well return
anything,  as  it  won't be used (or at least is undefined). That
means that I usually return  the  first  argument,  which  speeds
things up as I don't have to pop and push unessecary.

Many 'stack instructions' exists only to be called  by  the  com-
piler.  Like  instructions  are only generated explicitely by the
compiler, which knows what it does.

If you want to add a new function of you own, you  will  have  to
change:

lang.y: Define a new name 'F_XXX'. Add it last  in  the  list  of
'%token',  because the Makefile has not been instructed to recom-
pile every file depending on the order of the F_ definitions.

lex.c: add a  line  to  'predefs',  with  information  about  the
instruction.   Functions  that  only  allow  a constant number of
arguments are best, as the compiler always knows how  many  argu-
ments there is, and won't generated code information about that.

interpret.c: add a case statement in eval_instruction().  If  the
types of the arguments were specified, and only one type allowed,
then you will not have to check the types, but  can  assume  they
are  correct. If different types are allowed, then they will have
to be checked. Also, if the number  of  arguments  are  constant,
then  you  can  assume  they are correct. Otherwise, the variable
'num_var' will tell you the actual number of arguments.


TCP/IP buffering

It is well known that there is a lot of overhead on TCP/IP  pack-
ets.   Aproximately  60  bytes  will  be  added  to every packet.
Clients to LPmud (telnet) are run in local echo, line mode.  That
means that data from the player is not sent until he types a new-
line, and the whole line is sent.  This is an important  feature,
as  the  load  of the net is decreased.  A similar problem exists
for data sent from the game.  In this case, several small packets
can  be  sent,  adding a lot of overhead.  But, The TCP/IP has an
buffering, which means that data will not  be  sent  immediately.
It  will be buffered, and flushed after a short time.  The effect
is that most output from the game to the player are sent  as  one
packet,  except  for  large  amount of data or when the game runs
very slow.

























































