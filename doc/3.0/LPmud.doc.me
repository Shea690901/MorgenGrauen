.de SH
.sp 2
.sh \\$1 "\\$2"
.(x
\\$2
.)x
.sp 1
..
.de B
\fB
..
.de R
\fR
..
.pl 70
.nr Pt 1
.he '''%'
.(l C
\fB
LPmud, a programmable multi user game.
Lars Pensj|
lars@cd.chalmers.se
\fR
.)l
This is the (to be) documentation of LPmud and the LPC language.
If you know about a special fact not found, please add it, and send
me a patch.
Sorry if it is just a skeleton so far.
This document is for LPmud version 3.0.a5.
.sp 4
.bp
.SH 1 "General"
.SH  2 "Idea of the game"
LPmud is a multi user adventure game.
That means that several players can be playing the game at the same
time, using the same object database.
It also means that the players will meet each other, and affect the game
for other players.
.SH  2 "History of LPmud"
In the beginning, I played a lot of
Abermud and some Tinymud, and wanted to do something better, combining
the two systems.
I made the first version of LPmud as some kind of argument,
to show that my ideas were possible.
Luckily, I didn't know at that time
how that would impact my near future.
.SH  2 "Objects, files and programs"
The programs defining the behaviour of objects are stored in files.
Every object has exactly one file defining the program, but every file
may be used for more than one object.
When an object that is not loaded is referenced, it will automatically
be compiled and loaded.
More than one instance of an object can be created using the function
.i clone_object() .
.i clone_object() should not be used if only one instance of an object
is wanted.
Cloned objects may be configured differently after creation, hence
enabling different behaviour.
.SH  2 "To allow or not allow emote"
The following are some views that I (Lars Pensj|) have.
You are entirely free to depart from them.
There has been
some discussion on the net why only wizards have access to the 'emote'
command.

It was mentioned that some living objects listen to specific strings, which
would be possible to fake.
However, these objects should also verify that
the action that seemed to have happen, really did occur.
Many wizards do not
realize that the check is needed (even when there is no emote), and funny
things happen (I am not free of guilt either).

But that is not the real reason why I dislike 'emote' for non-wizards.
LPmud is a competition-based game.
In some versions, you are even
allowed to kill other players (with real bad results for the loser).
It would
be bad to allow the players to fake message that could be used in
combat situations.

The message 'Lars hit you with a poisoned knife' for example, could
scare of unknowing players.
When you see a message, you can be
pretty sure that it means what it says.
That is why there is the rule
that wizards should not do things that appears to do things that they really
don't do.
Non-wizards are not really supposed to be aware of the 'emote'
command (maybe naive to think so), which means that the wizards will appear
even more "god"-like.

I want LPmud to have big differences between wizards and non-wizards.
And
also big differences between low level players and high level players.
That
means some kind of class system.
But, the system will allow anyone that
work enough to reach the highest levels.

What all this boils down to, is that I want there to be several goals for the
players to reach.
Exciting goals makes the game more interesting, and
it is fun if everyone can be a winner.
.SH  2 "Socializing"
The original pub in LPmud, was created so that players could meet and have
some socializing.
I then implemented a scheme that forced players to become
drunk all the time.
.SH 1 "File hierarchy"
All files needed by the run time (game driver) resides in the
.i mudlib .
This directory contains several sub-directories and files.
.nr ii 10
.ip players
This directory contains all saved player files.
.ip ftp
A directory which might be open for anonymous ftp.
.ip room
All standard rooms available.
.ip obj
All objects that are used by standard rooms and player defined objects.
.ip log
.ip doc
.lp
.SH 1 "Commands tied to functions in objects"
All commands except a very few special cases are defined by the objects.
All commands have a simple basic way to be recognized.
The first word of the sentence is supposed to be the
.i verb .
Every command defined is tied to a special function in an object.
Commands are defined with the function
.i add_action() ,
which specifies the verb to be recognised, and the name of the local
function to be called.
When a living object gives a command which matches a verb with a command
defined by an object, then the corresponding function will be called in
the specified object.
If this function returns 0, then next command with the same verb is
tried.
If the function returns 1, then he search is terminated.
This enables several objects to define commands with the same verbs, but
still behave different if the rest of the sentence differs.
For example, there might be two armours. One is named "leather\ jacket",
and one is named "plate\ mail".
Both objects will have defined a command with the verb
.i wear .
If the player now gives the command "wear\ jacket", then we can't know
which defined command is called first.
Suppose that the
.i wear
function in the plate mail is called first.
It will then detect that the argument to
.i wear
is "jacket", not "plate\ mail".
It would then return 0, which would enable the game driver to call the
command in the leather jacket that defines the
.i wear
verb.
This function would accept the command, and execute some appropriate
code, followed by a return of 1.

Every time an object
.b O
comes in contact with a living object
.b L ,
then
.b O
will be asked to define commands.
See below in
.i What\ happens\ when\ objects\ are\ moved
for more information.
.SH 1 "Relation between object definitions"
Objects can reside either on top level, or inside another object.
There is no relation like "on", "behind" etc.
.SH  2 "The basic inheritance structure"
This is a picture of how basic object inheritance is built.
Below is a list of names, and what object inherits them.

.ip simul_efun
std/object and global/std/link_commands.
.ip std/object
std/container, std/weapon and std/armour.
.ip std/container
std/living.
.ip std/living.
std/player_sec.
.ip std/player_sec
std/player_pub
.ip global/std/link_commands
global/std/misc_cmd and global/std/soul_cmd.
.lp

A description of what is defined in the files.
.ip std/simul_efun
Here are LPC functions that are not defined in basic LPC, but should.
When they will become defined, they will be removed from this file.
For example, member_array(), map() exclude_array().
.ip std/object.
This is the basic file for all objects that will be visible to players.
Basic configuration functions are defined.
For example, set_name(), set_short(), set_value(), set_weight(),
add_prop(), move() and many more.
.ip std/container
This file is the base for all objects that are supposed to be able to
contain other objects.
Functions defined are add_item(), set_internal() and manipulation
of properties regarding containers.
.ip std/living
The base for all living objects in the game.
The fighting is defined here.
.ip std/player_sec
The base for all objects that an interactive player can connect to.
Functions defined here, are functions that wizards are not supposed to
be able to modify or redefine.
For example, the quest functions.
.ip std/player_pub
Default functions, possible to redefine by wizards who wants to make their
own player object.
.ip ?/player_race
?
.ip ?/player_guild
?
.ip ?/player_other
.lp
To std/player_sec are three soul-objects connected through links.
These are used in such a way, so that player_sec will ask the object
for a list of commands and functions, which are called.
.ip soul_cmd
Basic commands, like 'smile', 'laugh' etc.
.ip misc_cmd
All other player commands, like 'get', 'put', 'drop', 'help',
'bug', 'look' etc.
.ip Wizard soul
All wizard specific commands.
.lp

As soul_cmd and misc_cmd not is visible objects, they will only inherit
std/simul_efun and not std/object.
.SH 1 "Automatic call of functions in objects"
.SH  2 "What happens when objects are moved"
Every time an object is moved, a some code will be called an executed
automatically.
Below,
.i L
is a living object.
.np
When
.i L
is moved into a room, the function
.i init
will be called in both the room and in all other objects in that room.
.np
When an object is moved into the inventory of
.i L ,
or into the same room as
.i L ,
then
.i init
will be called in that object.
.lp
When objects are removed from the vincinity of
.i L ,
then all commands defined by these are objects are removed from the list
of commands available to
.i L .
.SH  2 "The reset of objects"
The function
.i reset
will be called in objects at two occasions.
The first occasion is when the object is loaded for the first time.
Then,
.i reset
will be called with 0 as argument.
The other occasion is at irregular intervals, where
.i reset
will be called repeatedly with argument 1.
The length of the interval is based on a constant defined by the person
that set the mud up, and plus/minus some random value.

A note of warning is in place here.
If there is a room defined like this:
.nf
reset(arg) {
	if (!present("troll")) {
		object troll;
		troll = clone_object("players/someone/troll");
		move_object(troll, this_object());
		}
	if (arg) return;
	set_light(1);
	short_desc = "My room";
	long_desc = ...
	dest_dir = ...
}
.fi
Then, the
.b troll
will be loaded into the room before the exits has been set up.
That means that the troll can't move.

There is another problem that should be known.
An object can be loaded from several reasons.
.np
When it is being moved.
.np
When a function is called in it.
.np
When it is cloned.
.np
When it is inherited by another object.
.lp
And in every instance of loading, reset() will be called with 0 as
argument.
.SH 1 "How to handle when a player enters a box etc"
Suppose there is a big box in the room, which makes it possible for
players to enter.
Players entering the box should not be transfered to the inventory of
the box, but rather to a new room, which would represent the interiour
of the box.

There is a specific reason for this.
When a player arrives to the room with the box, the function
.i init
will be called in the box, which will define the
.i enter
command.
But, if the player would be transfered into the box, he would again have
an
.i enter
command defined.
Similar problems exists for the
.i short()
and
.i long()
functions.
They should give different messages depending on if the player is on the
inside or the outside of the box.
.SH 1 "The security system"
Every object has two
.i uid s.
They are used for to determine if an object has permission to read and
write files, and to find out who owns an object.
They are named
.i uid
and
.i euid ,
and are strings.
The
.i uid
is the user id, and the
.i euid
is the effective user id.
When an object is created by either loading or cloning, then it will
have
.i uid
and
.i euid
initialized to the value of
.i euid
of the object that was the cause of the cloning or loading.
It is the
.i euid
that is used to determine permissions.
It can be changed to other values, using
.i seteuid() .
What it can be set to, is decided by
.i valid_seteuid()
in /obj/master.c.
It can always be set to '0'.
When it is '0', the object has no permissions at all.
It can not even clone or load other objects.

There is a function
.i getuid(object ob)
that returns the
.i uid
of the object
.i ob .
There is also a function
.i export_uid(object ob)
that sets the
.i uid
of object
.i ob
to the current
.i uid .
But, only if object
.i ob
has its current
.i euid
set to 0.

There are two functions,
.i valid_read
and
.i valid_write
defined in /obj/master.c.
They both take two arguments: a file name and an effective uid.
They will be called automatically by the game driver to determine if an
object has a specific permission.
They will return 0 or 1, for
.i no
and
.i yes .
Compare wih the old version of LPmud, where these two functions were
defined in player.c, and also modified the file name (using the current
working directory).

The function
.i get_root_id()
in /obj/master.c should return the
.i uid
that has permission to do anything.

When a castle is loaded automatically at startup, the
.i euid
must be set to the permission of the owner of the castle.
Thus, all objects loaded by this castle will inherit this
permission.
.SH  2 Example
Suppose we have a room "/players/martha/pit.c".
This room will have the same
.i uid
as the castle, which will probably be "martha".
If this room is initialized with a knife, defined from "/obj/weapon.c",
then this weapon will inherit the
.i uid
"martha".
.SH  2 Example
The player object will have the highest permission, which for instance
can be "root".
If the player is a wizard, then we don't want all objects cloned by the
wizard to have this
.i uid .
If the name of the wizard is "martha", then the player object will do a
call to
.i seteuid("martha")
at log in.
This will trigger a call to
.i valid_seteuid()
in /obj/master.c, which will return 1 because "root" is allowed to
change
.i uid
to anything else.
.SH  2 Example
So far, the examples shown has worked with no problems.
There is a problem, though, and that is when the a player moves from
(as an example) "/players/martha/pit.c" to "/room/vill_green.c".
If this "/room/vill_green.c" was not loaded, then it will promptly
become loaded,
.b but ,
it will get the
.i uid
"martha".
It should have the same
.i uid
as all standard rooms, which is maybe "root".
So, "/room/vill_green.c" will call
.i setuid("root")
in
.i reset() .
Then,
.i valid_seteuid()
will again be called, and this time it will accept the
.i uid
"root" because the file name shows that it is a standard object.
This all means that there is a bunch of objects that has to set their
.i uid s
to the correct values.
This will normally only be needed for rooms, and can easily be solved
by a call to
.i seteuid()
in the
.i reset()
defined by /room/room.c.
If a wizard makes his own room from scratch, then he better know what to
do.
If he fails to set his own
.i uid
for his own room, then his room can not
.i cat()
files in his directory etc.
.SH 1 "LPC reference manual"
The language used to program objects are called
.b LPC .
It is syntactically modelled after C.
As it is important that objects be loadable "on\ fly" in a game, I choose
to make it an interpreted language.
If it would be compiled for real, there would be big problems of portability
when moving to different machines.
The security of the program is also very important.
Under no circumstances should a LPC programmer crash the game by doing a
mistake.
That rules out standard C.

An LPC programs consists several building blocks:
.ip inheritance specifications
.ip preprocessor
.ip variables
.ip functions.
.lp
.SH  2 "Types declarations"
Types can be used at four places:
.np
Declaring type of global variables.
.np
Declaring type of functions.
.np
Declaring type of arguments to functions.
.np
Declaring type of local variables to functions.
.lp
Normally, the type information is completely ignored, and can be
regarded purely sa documentation.
However, when the basic type of a function is declared, then a more
strict type checking will be enforced.
That means that the type of all arguments must be defined.
And, the variables can only be used to store values of the declared
type.
The function
.i call_other
is defined to return an unkown type, as the compiler can't know the
type.
This value must always be casted (when strict type checking is enabled).
Casting a type is done by putting the type name inside a pair of '(' and
')'.
An example when querying the short description of an object:
.nf
(string)call_other(ob, "short");
.fi
There are two kinds of types.
Basic types, and special types.
There can be at most one basic type, but any number of special types.
The strict type checking is only used by the compiler, not by the
runtime.
Hence, it is actually possible to store a number in a string variable
even when strict type checking is enabled.

Why use strict type checking ?
It is really recommended, because the compiler will find many errors at
compile time, which will save a lot of hard work.
It is in general much harder to trace an error occuring at run time.
I recommend, that when a wizard is having problem with an object and
wants help, that he first must make all functions have declared types.
.SH   3 "Basic types"
.ip int
An integer 32 bit number.
.ip object
Pointer to an object.
An object pointer can mainly be used for two things.
Either giving as argument to functions, or used for calling
functions defined by that object with its specific instance of variables.
.ip string
An unlimited string of characters.
A lot of operators are allowed for strings, like
.b +
and
.b []
etc.
.ip mixed
This type is special, in that it is valid to use in any context.
Thus, if everything was declared
.i mixed ,
then the compiler would never complain.
This is of course not the idea.
It is really only supposed to be used when a variable really is going
to contain different types of values.
This
.b should
be avoided if possible.
It is
.b not
good coding practice, to allow a function for example to
return different types.
.ip void
This type is only usable for functions.
It means that the function will not return any value.
The compiler will complain (when type checking is enabled) if the return
value is used.
.lp
.SH   3 Arrays
Arrays are declared using a '*' with a basic type.
For example, declaring an array of numbers: "int\ *arr;".
Use the type
.i mixed
if you want an array of arrays, or a mixed combination of types.
.SH   3 "Special types"
There are some special types, which can be given before the basic type.
These special types can also be combined.
When using special type
.i T
before an
.i inherit
statement, all symbols defined by inheritance will also get the special
type
.i T .
The only special case is
.i public -defined
symbols, which can not be redefined as
.i private
in a
.i private\ inheritance
statement.
.ip private
Can be given for both functions and variables.
Functions that are
.i private
in object
.i A
can not be called through
.i call_other
from another object.
And, they are not accessible to any object that inherits
.i A .
.ip static
This special type behaves different for variables and functions.
It is similar to
.i private
for functions, in that they can not be called from other objects.
.i static
variables will be neither saved nor restored when calling
.i save_object ()
or
.i restore_object ().
.ip public
A function defined as
.i public
will always be accessible from other objects, even if
.i private\ inheritance
is used.
.ip nomask
All symbols defined as
.i nomask
can not be redefined by inheritance.
They can still be used and accessed as usual.
.lp
.SH  2 "Access of data and programs in other objects"
There is a function
.i call_other() ,
that can be used to call functions in nother objects.
All functions can be called except those declared
.i static
or
.i private .
See "Predefined\ functions" for more information.
There is another syntax that will do the same thing:

ob->func(args)

This will call function
.i func
in object
.i ob .
It is a much more good-looking way to do it.

There has been a lot of questions why this syntax hasn't been used to
allow for accessing variables in other objects.
There are some good reasons for that.
.np
It conflicts with the idea of programming in an object-oriented way.
.np
It makes the programming less structured, as there are more
dependencies.
If a variable name is changed, code can be broken.
Sometimes, you don't even want to keep the variable at all any longer.
.lp
.SH  2 "Predefined functions"
There are two kinds of predefined functions:
.ip efun
The functions
.i hard\ coded ,
which are defined by the game driver.
They can be redefined by a local function of the same name, which will
then be used instead.
.ip lfun
Functions that optionally can be defined by the objects.
These functions will be called by other
.i lfuns ,
and sometimes by the game driver.
They will control how the object will behave in special situations.
An example is
.i get() ,
which if defined and returning 1, will enable the object to be picked up
by players.
If returning 0, then the player will get a message that says that the
object can't be picked up.
.lp
.so lfun_efun.me
.SH  2 "Statements"
.SH   3 "if"
.SH   3 "block"
.SH   3 "while"
.SH   3 "do - while"
.SH   3 "for"
.SH   3 "return"
.SH  2 "Expressions"
.SH  2 "Saving and restoring objects"
.SH  2 "Inheritance"
.SH  2 "Compilation errors"
.SH  2 "Runtime errors"
.SH  2 "The preprocessor"
A number of preprocessor defined lines can be used.
They are very similar to the C preprocessor
.i /lib/cpp .
.ip #ifdef
Used for conditional compilation.
Takes a name as argument, and will leave or remove the following
code to the compiler until next
.i #endif
or
.i #else
depending on if the argument is a defined symbol or not.
See
.i #define
fro how to define symbols.
It is possible to have
.i #ifdef s
inside each others.
.ip #if
Same as
.i #ifdef
except the condition is evaluated as true if the argument evaluates as
non-zero.
.ip #endif
Used to terminate an
.i #if
or
.i #ifdef
clause.
.ip #else
Will toggle the conditional compilation.
.ip #define
Define a symbol.
The symbol can either be defined as another textual entity, or simply
defined to nothing.
In either case, the symbol will enable the
.i #ifdef
statment to evaluate as true.
If the symbol is defined as something, then that symbol will be replaced
with that something in the rest of the file.
Arguments can be used to define macros.
.ip #include
The string argument is evaluated as a file, which will be included at
that point.
A good rule is to never include files with LPC code in, only
prototypes and other preprocessor definitions.
.ip #pragma strict_types
Will force usage of type declarations in the rest of this file.
This is really recommended for complex files.
.lp
.SH 1 "The LPC implementation"
The language is defined by two files.
.i lex.c
defines the lexical elemements and takes care of preprocessor directives.
.i lang.y
defines the grammar.
.SH  2 "The virtual stack machine"
.SH  2 "How to add your own functions"
All predefined functions callable by the object must return exactly one
result on the stack, even if they are defined as 'void' functions. The
compiler assumes that there always are one resulting value.

The functions that returns the 'void' value, might as well return anything,
as it won't be used (or at least is undefined). That means that I usually
return the first argument, which speeds things up as I don't have to
pop and push unessecary.

Many 'stack instructions' exists only to be called by the compiler. Like
'pop', which obviously must not return a value on the stack. But, all those
instructions are only generated explicitely by the compiler, which knows
what it does.

If you want to add a new function of you own, you will have to change:

lang.y: Define a new name 'F_XXX'. Add it last in the list of '%token',
because the Makefile has not been instructed to recompile every file
depending on the order of the F_ definitions.

lex.c: add a line to 'predefs', with information about the instruction.
Functions that only allow a constant number of arguments are best, as the
compiler always knows how many arguments there is, and won't generated
code information about that.

interpret.c: add a case statement in eval_instruction(). If the types of
the arguments were specified, and only one type allowed, then you will
not have to check the types, but can assume they are correct. If different
types are allowed, then they will have to be checked. Also, if the number
of arguments are constant, then you can assume they are correct. Otherwise,
the variable 'num_var' will tell you the actual number of arguments.
.SH  2 "TCP/IP buffering"
It is well known that there is a lot of overhead on TCP/IP packets.
Aproximately 60 bytes will be added to every packet.
Clients to LPmud (telnet) are run in local echo, line mode.
That means that data from the player is not sent until he types a
newline, and the whole line is sent.
This is an important feature, as the load of the net is decreased.
A similar problem exists for data sent from the game.
In this case, several small packets can be sent, adding a lot of
overhead.
But, The TCP/IP has an
.i internal
buffering, which means that data will not be sent immediately.
It will be buffered, and flushed after a short time.
The effect is that most output from the game to the player are sent as
one packet, except for large amount of data or when the game runs
very slow.
' Local Variables:
' mode: outline
' eval: (auto-fill-mode 1)
' eval: (setq doc-syntax (make-syntax-table))
' eval: (set-syntax-table doc-syntax)
' eval: (modify-syntax-entry ?{ "w")
' eval: (modify-syntax-entry ?} "w")
' eval: (modify-syntax-entry ?[ "w")
' eval: (modify-syntax-entry ?] "w")
' eval: (modify-syntax-entry ?| "w")
' outline-regexp: "^.SH 1\\|^.SH  2\\|^.SH   3\\|^.SH    4\\|^' Local Variables:"
' fill-column: 72
' eval: (hide-body)
' End:
.bp
.he '''
.xp
