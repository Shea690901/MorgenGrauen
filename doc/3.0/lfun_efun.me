.SH   3 "efuns"
.SH    4 "add_action"
void add_action(string fun, string cmd, int flag);

Set up a local function "fun" to be called when user input matches the 
command "cmd". Functions called by a player command will get the arguments
as a string. It must then return 0 if it was the wrong command, otherwise 1.

If it was the wrong command, the parser will continue searching for another
command, until one returns true or give error message to player.

For example, there can be a wand and a rod. Both of these objects defines
add_verb("wave"). One of them will be randomly called first, and it must
look at the argument, and match against "wand" or "rod" respectively.

If seconds argument ("cmd") is not give, it must be given by add_verb().
Support of add_verb() is of historical reasons.

Always have add_action() called only from an init() routine. The object that
defines commands must be present to the player, either being the player,
being carried by the player, being the room around the player, or being an
object in the same room as the player.

If argument 'flag' is 1, then only the leading characters of the command has
to match the verb 'cmd'.

Never define an action that will call the function exit(), because it is
a special function.

See also efun/query_verb, efun/add_verb, lfun/init, lfun/exit
.SH    4 "add_verb"
void add_verb(string str);

This function is connected to the "add_action()" function. It will set up
the command "str" to trigger a call to the function set up by the
previous call to "add_action()".

This function is now obsolete as the verb can be given directly with
add_action(). add_verb() remains for compatibility.

See also efun/add_action efun/query_verb
.SH    4 "all_inventory"
all_inventory(object ob);

Returns an array of the objects contained in the inventory of "ob".

See also first_inventory(), next_inventory().
.SH    4 "allocate"
allocate(int size);

Allocate an array of 'size' elements. The number of elements must
be >= 0 and not bigger than a system maximum (usually 1000).

See also: efun/sizeof
.SH    4 "call_other"
call_other(object ob, string str, mixed arg);

Call function in another object with an argument. The return value is
returned from the other object.

See also present(), find_living().
.SH    4 "call_out"
void call_out(fun, delay, arg)
string fun;
int delay;

Set up a call of function 'fun' in this_object(). The call will take place
in 'delay' seconds, with the argument 'arg' provided. 'arg' can be of
any type.

Please note that you can't rely on 'write' or 'say' in the 'fun' called
since this_player() is set to 0. Use 'tell_object()' instead.

See also efun/remove_call_out efun/call_out_info
.SH    4 "capitalize"
string capitalize(string str);

Convert the first character in "str" to upper case, and return the
new string.

See also efun/lower_case
.SH    4 "cat"
int cat(string path, int start, int num);

List the file found at "path". It is not legal to have '.' or spaces
in the path. This commands is normally connected to the "cat" command
that wizards have. It is also used by the "help" command. The optional
arguments 'start' and 'num' makes is start line number, and number of lines.
If they are not given, the whole file is printed from the beginning.

The total number lines will not exceed a system limit, which normally
is 40 lines.

cat() returns 1 if success, 0 if no such file or no such lines.

See also efun/ls efun/file_size efun/read_file
.SH    4 "catch"
catch(expr)

Evaluate 'expr'. If there is no error, 0 is returned. If there is a
standard error, a string (with a leading '*') will be returned.

The function throw(value) can also be used to immediately return any value,
except 0. catch() is not really a function call, but a directive to the
compiler.

The catch() is somewhat costly, and should not be used anywhere. Rather,
use it at places where an error would destroy consistency.

See also efun/throw
.SH    4 "clear_bit"
string clear_bit(string str, int n);

Return the new string where bit 'n' is cleared in string 'str'. Note that
the old string 'str' is not modified.

See also efun/set_bit efun/test_bit
.SH    4 "clone_object"
object clone_object(string name);

Load a new object from definition "name", and give it a new
unique name. Return the new object.
The original used for cloning, should not be used in the game, only used for
cloning.

See also efun/destruct efun/move_object
.SH    4 "command"
int command(string str, object ob);

Execute "str" as a command given directly by the player.
Any effects of the command will apply to the current object.
If the second optional argument is present, then the command is executed
for that object.

Return value is 0 for failure. Otherwise, a numeric value is returned, which
tells the evaluation cost. Bigger number means higher cost. The evaluation
cost is approximately the number of of machine code instructions executed.

See also efun/enable_commands
.SH    4 "create_wizard"
string create_wizard(string name);

Create the environment and castle for a wizard. Do NOT use this if you
are not sure about what you are doing !
It will create a new directory for wizard with the name "name", and
copy a definition of a castle to this directory. It will also
set up automatic loading of this castle for the start of the game.

It returns the name of the new castle. In case of error, 0 is returned.
.SH    4 "creator"
string creator(ob)
object ob;

Return as a string the name of the wizard that created object 'ob'. If
the object was not created by a wizard, 0 is returned.
.SH    4 "crypt"
string crypt(str, seed);

Crypt the string 'str' using two characters from 'seed' as a seed. If
'seed' is 0, then random seed is used :-)

The result has the first two characters as the seed.
.SH    4 "ctime"
string ctime(clock)
int clock;

Give a nice string with current date and time, with the argument 'clock'
that is the number of seconds since 1970.

See also: efun/time
.SH    4 "destruct"
void destruct(ob)
object ob;

Completely destroy and remove object "ob". The argument can also be a string. 
After the call to destruct(), no global variables will exist any longer,
only local, and arguments.

If an object self-destructs, it will immediately terminate execution and
return 0. There is one exception: If the destruct-statement is followed by
a 'return 1' immediately after, then this return statement will be executed.

This should NOT be used on normal objects in the game, instead use the lfun
'remove' in the object you want removed: ob->remove(); This will ensure
correct update of weights, volumes etc

See also clone_object().
.SH    4 "ed"
void ed(file)
string file;

This is a funny function. It will start a local editor on an optional file.
This editor is almost ed compatible.
.SH    4 "enable_commands"
void enable_commands()

Enable this object to use commands normally accessible to players.
This also marks the current object as "living".
Commands defined by 'player.c' will not be accessible, of course.

This function must be called if the object is supposed to interact
with other players.

Avoid to call this function from other places then reset(), because the
command_giver will be set to the this object.

See also efun/command, efun/living.
.SH    4 "environment"
object environment(obj)
object obj;

Return the surrounding object to "obj". If no argument is giving,
it returns the surrounding to the current object.
The object will dissapear silently without any sign.

See also find_first_inventory(), this_player(), this_object().
.SH    4 "explode"
explode(str, del)
string str, del;

Return an array of strings, created when the string 'str' is splitted
into substrings as divided by 'del'. The 'str' must end with 'del' if
the last part is wanted too.

Example: explode(str, " ") will split the string 'str' into an array of
words as separated by spaces in the original string. The array is returned.

See also: efun/sscanf efun/extract efun/sscanf
.SH    4 "extract"
string extract(string str, int from, int to)

Extract a substring from a string. Character 0 is first character.
"extract(str, n)" will return a substring from characer number 'n' to the end.
"ectract(str, i, j)" will return a string from character 'i' to
character 'j'.

See also efun/sscanf efun/explode
.SH    4 "object_name"
string object_name(ob)
object ob;

Get the file name of an object. If the object is a cloned object, then
it will not have any corresponding file name, but rather a new name
based on the original file name.

Example: "find_object(object_name(ob)) == ob" is guaranteed to be true for
all objects 'ob'.
.SH    4 "file_size"
int file_size(file)
string file;

Give the size of a file. Size -1 indicates that the file either does not
exist, or that it is not readable by you. Size -2 indicates that it is
a directory.

See also: efun/save_object efun/load_object efun/write_file efun/cat
.SH    4 "find_living"
object find_living(str)
string str;

Find first "living" object that answers to the id "str" (by calling
local id()). A living object is an object that has done "enable_commands()".

The object must have set a name with 'set_living_name()'. There is a special
hash table that speeds up the search for living objects.

See also efun/find_player efun/enable_commands efun/set_living_name
.SH    4 "map"
pointerp map(arr, fun, ob, extra)
pointerp arr;
string fun;
object ob;

Returns an array holding the items of 'arr' mapped through ob->fun().
The function 'fun' in 'ob' is called for each element in 'arr' with that
element as parameter. A second parameter 'extra' is sent in each call if
given. Principal function: 
	foreach (index) arr[index] = ob->fun(arr[index],extra);

The value returned by ob->fun(arr[.index.], extra) replaces the existing 
element in the array. If 'arr' is not an array, then 0 will be returned.
.SH    4 "find_object"
object find_object(str)
string str;

Find an object with the file name 'str'. If the file isn't loaded, it will
not be found.
.SH    4 "find_player"
object find_player(str)
string str;

Find a player with the name 'str'. The string must be lowercase. Players
are found even if they are invisible or link dead. Monsters are not found.

This function uses the name that was set by 'set_living_name()'. This
is done automatically in player.c.

See also efun/find_living efun/set_living_name
.SH    4 "first_inventory"
object first_inventory(ob)
object ob;

Get the first object in the inventory of "ob".

See also next_inventory(), all_inventory().
.SH    4 "function_exists"
string function_exists(str, ob)
string str;
object ob;

Return the file name of the object that defines the function 'str' in
object 'ob'. The returned value can be other than object_name(ob) if the
function is defined by an inherited object.

0 is returned if the function was not defined.
.SH    4 "implode"
string implode(arr, del)

Concatenate all strings found in array 'arr', with the string 'del' between
each element. Only strings are used from the array.

See also: efun/explode
.SH    4 "input_to"
void input_to(fun, flag)
string fun;
int flag;

Enable next line of user input to be sent to the local function "fun" as
an argument. The input line will not be parsed.

Note that "fun" is not called immediately. It will not be called until
the current execution has terminated, and the player has given a new
command.

If input_to() is called more than once in the same execution, only the
first call has any effect.

If optional argument 'flag' is non-zero, the line given by the player will
not be echoed, and is not seen if snooped.

See also call_other(), sscanf().
.SH    4 "intp"
int intp(arg)

Return 1 if 'arg' is an integer number.

See also efun/stringp, efun/pointerp, efun/objectp
.SH    4 "living"
int living(ob)
object ob;

Return true if 'ob' is a living object (that is, enable_commands() has been
called by 'ob').
.SH    4 "log_file"
void log_file(file, message)
string file;
string message;

Append a message to a log file. All log files are in the directory
mudlib/log.

'/log' is automatically prepended to the file name.

See also: efun/write_file
.SH    4 "lower_case"
string lower_case(str)
string str;

Convert the all characters in "str" to lower case, and return the
new string.
.SH    4 "ls"
void ls(path)
char path;

List files in an optional path. It is not allowed to use '.' or
space in the path. This function is normally connected to the "ls"
command that a wiz have.

See also cat().
.SH    4 "move_object"
void move_object(item, dest)
object item;
object dest;

Move the object "item" to the object "dest". Currently, both arguments
can be strings. Usually, 'transfer()' should be used instead of
'move_object()'.

See also efun/transfer, efun/first_inventory, efun/this_object,
	 efun/this_player
.SH    4 "next_inventory"
object next_inventory(ob)
object ob;

Get next object in the same inventory as "ob".

Warning: If the object 'ob' is moved by move_object(), then next_inventory()
will return an object from the new inventory.

See also efun/first_inventory, efun/all_inventory.
.SH    4 "notify_fail"
void notify_fail(string str);

Store 'str' as the error message given instead of the default
message 'What ?'.

If notify_fail() is called more than once, only the last call of
will be used.

The idea of this function is to give better error messages instead of
simply 'What ?'.
.SH    4 "objectp"
int objectp(arg)

Return 1 if 'arg' is an object.

See also efun/intp, efun/stringp, efun/pointerp
.SH    4 "parse_command"
int parse_command(string str, mixed source, string pattern, var1, var2 ...);

Parses commands given in "str" against the pattern in "pattern" and
returns 1 if it matches. "source" is either an object or an array of objects.
This is essentially a 'hotted' sscanf and it has a similar syntax, although
parse_command works on word basis where sscanf works on character basis.

.ip str
Given command
.ip source
Either an array holding the accessible objects, or
an object from which to recurse and create
the list of accessible objects, normally
ob = environment(this_player()) .

.ip pattern
Parse pattern as list of words and formats:
.nf
		Syntax:
			'word' 		obligatory text (One word)
			[word]		optional text (One word)
			/		Alternative marker
			%o		Single item, object
			%l		Single living object
			%s		Any text (multiple words)
			%w              Any word
			%p		Preposition
			%i		Any items
			%d              Number 0- or tx(0-99)
.fi
Example string: " 'get' / 'take' %i " .
Items as in %o and %i can on many forms, some examples:
.nf
			apple, two apples, twentyfirst apple
			apples, all apples, all green apples, all green ones
.fi

.ip varN
This is the list of result variables as in sscanf.
One variable is needed for each %_.
The return types of different %_ is:
.nf
	%o	Returns an object
	%l	Returns an object
	%s	Returns a string of words
	%w      Returns a string of one word
	%p	Can on entry hold a list of word in array
		or an empty variable
		Returns:
		   if empty variable: a string
		   if array: array[0]=matched word
	%i	Returns a special array on the form:
		[0] = (int) given numeric prefix
		       =0: all or a pluralform given
		       >0: numeral given: two, three, four...
		       <0: order given: second, third ...
		[1..n] (object) Objectpointers
		       A list of the POSSIBLE objects that can match
		       the given %i. No choosing of third or such.
	%d      Returns a number
.fi
.lp
Example:

a=parse_command("take apple",environment(this_player()),
	 " 'get' / 'take' %i ",items);

.SH    4 "people"
void people()

A function that will list all interactive players, and some info
about them. This function is normally connected to the "people" command,
that wizards have.

THIS FUNCTION IS OBSOLETE. LOOK AT efun/users() INSTEAD.
.SH    4 "pointerp"
int pointerp(arg)

Return 1 if 'arg' is a string.

See also efun/intp, efun/stringp, efun/objectp
.SH    4 "present"
object present(str, ob)
string str;
object ob;

If an object that identifies to the name "str" is present,
then return it.

'str' can also be an object.

The object is searched for in the inventory of the current object, and
in the inventory of the environment of the current object.

A second optional argument 'ob' is the enviroment where the search for the
'str' is done. Normally 'this_player()' is a good environment.

See also efun/move_object(), efun/environment().
.SH    4 "previous_object"
object previous_object()

Returns an object pointer to the object that called current function,
if any.

See also: efun/call_other
.SH    4 "query_idle"
int query_idle(ob)
object ob;

Query how many seconds idle a player object has been.
.SH    4 "query_verb"
string query_verb()

Give the name of the current command, or 0 if not executing from
a command. This enables add_action() of several commands to teh same
function.

See also efun/add_action().
.SH    4 "random"
int random(n)
int n;

Return a number in the random range [0 .. n-1].
.SH    4 "remove_call_out"
int remove_call_out(fun)
string fun;

Remove next pending call out for function 'fun' in this object. The time left
is returned.

-1 is returned if there were no call out pending to this function.

See also efun/call_out efun/call_out_info
.SH    4 "save_object"
void save_object(name)
string name;

Save values of variables of this object in the file "name".
It is illegal to have '.' or space in the field name. Wizards that call
this function can only save to files in their own directories.

Objectpointers are stored as the number '0'.
Variables that has the type modifer 'static' will not be saved. 
Example: 'static int xxx;'.

See also efun/restore_object
.SH    4 "restore_object"
int restore_object(name)
string name;

Restore values of variables for current object from file "name".
It is illegal to have '.' or spaces in the name.
Return true if success.

Variables that has the type modifer 'static' will not be saved.
Example: 'static int xxx;'.

See also efun/save_object
.SH    4 "say"
void say(str)
string str;

void say(str,obj)
string str;
object obj;

Send a message "str" to all players in the same object (room).
This function is also used by the "say" command.

If second argumnet "obj" specified, messages is semt to all except "obj".

This commands behaves differently if called from a heart_beat(), or otherwise.
When called from a heart_beat(), the message will reach all players in
the same environment of the object that calls say().

See also write(), shout(), tell().
.SH    4 "set_bit"
string set_bit(str, n)
string str;
int n;

Return the new string where bit 'n' is set in string 'str'. Note that
the old string 'str' is not modified.

The max value of 'n' is limited. Ask the administrator if you want to
now the maximum value.

The new string will automatically be extended if needed.

Bits are packed 6 per byte in printable strings.

See also efun/clear_bit efun/test_bit
.SH    4 "set_heart_beat"
int set_heart_beat(flag)
int flag;

Enable or disable heart beat. If the heart beat is not needed for the moment,
then do disable it. This will reduce system over head.

Return true for success, and false for failure. Specifically, it will
fail if the heart beat function has been disabled, which it will be
if there is a run time error in it.

See also lfun/heart_beat
.SH    4 "set_light"
int set_light(n)
int n;

An object is by default dark. It can be set to not dark by calling
set_light(1). The environment will the also get this light.
The returned value is the total number of lights in this room.

Note that the value of the argument is added to the light of the
current argument !
.SH    4 "set_living_name"
void set_living_name(name)
string name;

Set a living name on an object that must be living. When this is done, the
object can be found with find_living().

An object can only have one name that can be searched for with find_living().

See also efun/find_living efun/find_player
.SH    4 "shout"
void shout(str)
string str;

Send a string "str" to all players. This function is also used by the
"shout" command.

See also write(), tell_object(), say().

.SH    4 "sizeof"
int sizeof(arr)

Return the number of arguments of an array 'arr'.
If 'arr' is not an array, then '0' is returned.

See also: efun/allocate
.SH    4 "slice_array"
slice_array(arr,from,to)
array arr;
int from;
int to;

Returns an array that is a slice of the array 'arr' from the index 'from' to
the index 'to'. Indexes are numbered 0-

If 'arr' is not an array or indexes are outside the limits of 'arr', 
then 0 will be returned.

Note also that you can use the operator '+' on arrays.

.SH    4 "sscanf"
int sscanf(str, fmt, var1, var2 ...)
string str;
string fmt;

Parse a string "str" using the format "fmt". "fmt" can contain strings
separated by "%d" and "%s". Every "%d" and "%s" corresponds to one
of var1, var2...
"%d" will give a number, and "%s" will give a string.

Number of matched "%d" and "%s" is returned.

See also efun/extract efun/explode.
.SH    4 "stringp"
int stringp(arg)

Return 1 if 'arg' is a string.

See also efun/intp, efun/pointerp, efun/objectp
.SH    4 "tell_object"
void tell_object(ob, str)
object ob;
string str;

Send a message "str" to object "ob". If it is an interactive object (a player),
then the message will go to him, otherwise it will go to the local
function "catch_tell".

See also write(), shout(), say().
.SH    4 "tell_room"
void tell_room(ob, str)
object ob;
string str;

Send a message "str" to object all objects in the room "ob".
'ob' can also be the name of the room (string).

See also efun/write, efun/shout, efun/say, efun/tell_object
.SH    4 "test_bit"
int test_bit(str, n)
string str;
int n;

Return 0 or 1 of bit 'n' was set in string 'str'.

See also: efun/set_bit efun/clear_bit
.SH    4 "this_object"
object this_object()

Return the object pointer of this object. This is not to be confused with the
internal name of an object, which is used by the "id()" function.

See also: this_player().
.SH    4 "this_player"
object this_player()

Return the object representing the current player.

See also: this_object().
.SH    4 "time"
int time()

Return number of seconds since 1970.

See also: efun/ctime
.SH    4 "getuid"
string getuid(object ob)

Get the name of the wizard that is set to the user of this object.
That name is also the name used in the wizlist.

See also efun/seteuid
.SH    4 "users"
users()

Return an array of objects, containing all interactive players.
.SH    4 "write"
void write(str)
string str;

Write a message "str" to current player. "str" can also be a number, which
will be translated to a string.

See also: say(), tell_object(), shout().
.SH    4 "write_file"
int write_file(file, str)
string file, str;

Append the string 'str' into the file 'file'. Returns 0 or 1 for
failure or success.

See also: efun/file_size efun/cat efun/log_file
.SH    4 "rm"
int rm(string file)

Remove file 'file'. Returns 0 for failure and 1 for success.

See also efun/mkdir efun/rmdir
.SH    4 "filter"
pointerp filter(mixed *arr, string fun, object ob, mixed extra);

Returns an array holding the items of 'arr' filtered through ob->fun().
The function 'fun' in 'ob' is called for each element in 'arr' with that
element as parameter. A second parameter 'extra' is sent in each call if
given. If ob\->fun(arr[.index.],\ extra) returns 1 the element is included in
the returned array. 

If 'arr' is not an array, then 0 will be returned.
.SH    4 "unique_array"
pointerp unique_array(obarr,separator)
pointerp obarr;
string separator;

Groups objects together for which the 'separator' function returns the same 
value. 'obarr' should be an array of objects, other types are ignored.
The 'separator' function is called only once in each object in 'obarr'. The
return value is an array of arrays of objects on the form:

   ({
       ({Same1:1, Same1:2, Same1:3, .... Same1:N }),
       ({Same2:1, Same2:2, Same2:3, .... Same2:N }),
       ({Same3:1, Same3:2, Same3:3, .... Same3:N }),
                     ....
                     ....
       ({SameM:1, SameM:2, SameM:3, .... SameM:N }),
   })
	

.SH    4 "export_uid"
int export_uid(object ob)

Set the uid of object 'ob' to this_object's effective uid. It is only possible
when object 'ob' has an effective uid of 0.

See also efun/seteuid efun/getuid
.SH    4 "seteuid"
int seteuid(string str)

Set effective uid to 'str'. It is not possible to set it to any string.
It can always be set to getuid(), the creator of the file for this object
or 0.

When this value is 0, then current objects uid can be changed by export_uid,
and only then.

But, when the value is 0, no objects can be loaded or cloned by this object.

See also efun/export_uid efun/getuid
.SH    4 "call_out_info"
mixed *call_out_info()

Get information about all pending call outs. An array is returned,
where every item in the array consists 4 elements:

.np
The object.
.np
The function.
.np
The delay to go.
.np
The optional argument.
.lp

See also: efun/call_out efun/remove_call_out
.SH    4 "read_file"
string read_file(string file);

Return the contents of the file 'file'. There is a maximum limit.

See also: efun/file_size efun/cat efun/log_file efun/write_file
.SH    4 "throw"
void throw(mixed val);

Terminate execution, and make the currently executing 'catch()' return 'val'.

See also efun/catch
.SH   3 "lfuns"
.SH    4 "move"
int move(object dest);

Move the object to the object "dest". All kinds of tests are done,
and a number is returned specifying the result:

.nf
0: Success.
1: To heavy for destination.
2: Can't be dropped.
3: Can't take it out of it's container.
4: The object can't be inserted into bags etc.
5: The destination doesn't allow insertions of objects.
6: The object can't be picked up.
.fi

If an object is transfered to a newly created object, make sure that the
new object first is moved to it's destination.


