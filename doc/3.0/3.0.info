Here are some of the new features available with the 3.0 Gamedriver.

1) Multiple Inheritance: You can use more than one inherit statement
   per file, e.g.:

   inherit "obj/weapon";
   inherit "obj/armour";

   reset(arg)
   {
     weapon::reset(arg); /* Call reset in "obj/weapon". */
     armour::reset(arg); /* Call reset in "obj/armour". */
     if (arg) return;
     /* some stuff to initialize the combined weapon/armour */
   }

   You also can use ::reset(arg) instead of weapon::reset(arg). If
   a function is defined in more than one inherited file, only the
   function in the first file that defined it is called.
   This feature can also be abused for inheriting library-objects, i.e.
   objects which define functions which you don't want to call via
   -> or call_other. But don't forget that the variables of the
   inherited objects use up memory if there are many of them.
   There are further features connected with the new inheritance scheme
   which will be explained at a later date.

2) New Types: There are now the following new types for declaring
   variables, functions and their arguments:

   mixed: A variable of this type is actually typeless, i.e. it can
	  be an integer, string, object, etc.
   void: Only functions may be declared void, which implies that they
	won't return a value.
   <type> *: This declares an array of elements of type <type>. Note
	     that <type> may be only a basic type, i.e. int, string,
	     object, etc. If you need an array of arrays or a similarly
	     weird construct, use mixed * for the declaration.
3) Strict type checking: you can enforce strict type checking by
   writing:

   #pragma strict_types
   
   at the start of your file. Thereafter all your code will be checked
   for not using int vars to store strings etc. Also the type of functions
   and their arguments HAVE TO be declared, i.e.

   void reset(int arg) { /* some stuff */ }

   You can always resort to mixed as a type if you don't like this kind
   of type-checking.

4) New external functions: The following list is incomplete, but it
   will give you an impression of what can be accomplished by the
   new efuns.

   object *all_inventory(object ob) returns an array consisting of
   all the objects in the inventory of ob. If the inventory is empty,
   0 is returned.

   void disable_commands() undoes the effects of enable_commands().

   mixed *filter_objects(mixed *p,string func,object ob,mixed extra)
   calls ob->func(p[i],extra) for all i in 0..sizeof(p)-1 and returns
   an array consisting of all objects that the function call returned
   a nonzero value for. The extra argument may be omitted.

   mixed *map(mixed* p,string func,object ob,mixed extra) does
   a p[i]=ob->func(p[i],extra) for all i in 0..sizeof(p)-1 and returns
   the resulting array. The original array isn't changed by the call.
   Again extra is an optional argument.

   int member_array(mixed elem,mixed *arr) will search for elem as
   an item in array arr, and return the index if found. Otherwise,
   -1 is returned.

   mixed *slice_array(mixed *p,int from,int to) returns an array
   holding the elements p[from], p[from+1], ..., p[to].

